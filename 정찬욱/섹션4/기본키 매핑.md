# 기본키 매핑 어노테이션
## @Id
* 직접 할당을 하고 싶다면 @Id만 선언하면 됨.
  * ex) id가 String이거나 특정값이거나...


## @GaneratedValue
* 만약 sequence와 같이 DB에 위임해서 자동으로 값이 증가되길 훤한다면 @GaneratedValue를 같이 선언해준다.
  * MySQL : IDENTITY, Oracle : SEQUENCE(@SequenceGenerator 필요함)
* TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용함.
  * @TableGenerator 필요
* AUTO : 방언에 따라 자동으로 지정, 기본값임.
    ```java
    @Id
    @GeneratedValue(strategy = GenerationType.Auto)//
    private String id;
  /*
  GenerationType.Auto : 오라클이라면 시퀀스가 생성됨.
  */
    ```
### Sequence전략
* 유일한 값을 순서대로 생성하는 특별한 DB오브젝트 
* 주로 오라클, PostgreSQL, H2등에서 사용됨.
* 그냥 사용하면 hibernate_sequence로 시퀀스가 작성되는데 보통 테이블명을 가진 시퀀스명을 만들고 싶어함
  ```java
    @Entity
    @SequenceGenerator(
    name = “MEMBER_SEQ_GENERATOR",// @SequenceGenerator의 이름
    sequenceName = “MEMBER_SEQ", // MEMBER_SEQ의 이름으로 시퀀스가 생성됨.
    initialValue = 1, allocationSize = 1)
    public class Member {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
    generator = "MEMBER_SEQ_GENERATOR") //아까 생성한@SequenceGenerator의 이름을 매핑해준다.
    private Long id;
``


 ### Table 전략
* 키 생성 전용 테이블을 하나 만들어서 DB 시퀀스를 흉내내는 전략
* 장점은 모든 DB에서 사용이 가능하지만 성능이 다소 떨어짐(시퀀스는 최적화가 잘 되어있지만 테이블 매핑은 아님.)
* 운영에서 쓰기엔 어려움. 그냥 이런게 있다 정도...

    ```sql
    create table MY_SEQUENCES (
    sequence_name varchar(255) not null,
    next_val bigint,
    primary key ( sequence_name )
    ); //sql로 따로 숫자 생성용 테이블을 하나 뽑아도 됨.
  ```
  ```java
    @Entity
    @TableGenerator(//아니면 TableGenerator로 하나 뽑아도 됨.
    name = "MEMBER_SEQ_GENERATOR",
    table = "MY_SEQUENCES",
    pkColumnValue = “MEMBER_SEQ", allocationSize = 1)
  
    public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE,
    generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
  
    ```
    만들어준 숫자 생성용 테이블을 이름으로 매핑을 해주어 사용
 #### 권장하는 식별자 전략
*  기본 키 제약 조건 : null아님, 유일해야하고 , 변하면 안됨.
* 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자 -> 주민등록번호를 과거에는 pk로 많이 썼는데 개인정보보호법 나오고 부터 몇년이내에 삭제해야 하는 경우가 있기도 했음.
* 권장 : Long Tyle + 대체키 + 키 생성전략 사용.


### Identity 전략
