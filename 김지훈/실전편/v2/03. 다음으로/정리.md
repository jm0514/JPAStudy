# V1 : 엔티티 직접 노출
- 엔티티가 변하면 API 스펙이 변하는 단점이 존재.
- 양방향 연관관계 문제 발생 (무한 루프) -> @JsonIgnore 을 붙여주어야 함
- 엔티티를 직접 노출하므로 좋은 방법 X

# V2 : 엔티티를 DTO로 변환 (fetch join X)
- 트랜잭션 내에서 지연 로딩 필요
- 지연 로딩에 따른 너무 많은 SQL 실행이 된다는 단점이 존재.
- N + 1 문제 발생

# V3 : 엔티티를 DTO로 변환 - 페치 조인 최적화
"select distinct o from Order o"
    + " join fetch o.member m"
    + " join fetch o.delivery d"
    + " join fetch o.orderItems oi"
    + " join fetch oi.item i", Order.class)
- 페치 조인으로 SQL이 1번만 실행된다. 1대다 조인이 있으므로 데이터베이스 row가 증가. 그 결과 order 엔티티 조회수도 증가.
- JPA의 distinct는 SQL에 distinct를 추가한 것에서 중복된 데이터는 걸러준다.
- 페이징이 불가능하다는 단점이 있다.

# V3.1 : 엔티티를 DTO로 변환 - 페이징과 한계 돌파
- 페이징 + 컬렉션 엔티티를 함께 조회하려면 먼저 
1. ToOne 관계는 모두 페치 조인
2. 컬렉션은 지연 로딩으로 조회
3. 지연 로딩 성능 최적화를 위해 배치 사이즈를 yml 이나 애노테이션을 활용해 지정해준다.

### 장점
- N + 1 -> 1 + 1 로 쿼리 수 최적화
- 조인보다 DB 데이터 전송량이 최적화.
- DB 데이터 전송량이 감소.
- 페이징 가능.

> 따라서, ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않음. ToOne 관계는 페치 조인으로 쿼리 수를 줄이고 나머지는 hibernate.default_batch_size로 최적화.

# V4: JPA에서 DTO 직접 조회
- 쿼리는 루트 1번, 컬렉션 N번 실행.
- ToOne 관계들을 먼저 조회하고, ToMany 관계는 각각 별도로 처리.
  - ToOne 관계는 조인해도 데이터 row 수가 증가하지 않는다.
  - ToMany(1:N) 관계는 조인하면 row 수가 증가.
- row 수가 증가하지 않는 ToOne 관계는 조인으로 최적화하기 쉬워 한 번에 조회하고, ToMany 관계는 최적화하기 어려우므로 별도 메서드로 조회.

# V5: JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화
- Map 을 사용해서 매칭 성능 향상 (O(1))
- ToOne 먼저 조회, 조회한 식별자로 ToMany 관계를 한꺼번에 조회

# 권장 순서
1. 엔티티 V2 ... 조회 방식으로 접근 
2. 페치 조인으로 쿼리 수 최적화
3. 컬렉션 최적화 
   - 페이징 필요시 배치 사이즈 지정.
   - 페이징 필요 없을 시 페치 조인 사용
4. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
5. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate

