# 도메인 분석 설계
## 외래 키가 있는 곳을 연관관계의 주인으로 정해라.
- 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지 비즈니스상 우위에 있다고 주인으로 정하면 안된다. 
- 예를 들어 자동차와 바퀴가 있을 때 일대다 관계에서 항상 다쪽에 외래 키가 있으므로 바퀴를 연관관계의 주인으로 정하면 된다. 물론
자동차를 연관관계의 주인으로 정하는 것이 불가능한 것은 아니지만 자동차를 연관관계의 주인으로 정하면 자동차가 관리하지 않는 바퀴
테이블의 외래 키 값이 업데이트 되므로 관리 및 유지보수가 어렵고, 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 존재.

## 엔티티 클래스 개발
- 실무에서는 가급적 Getter는 열어두고, Setter는 꼭 필요한 경우에만 사용.
- 이론적으로 Getter, Setter 모두 제공하지 않고, 꼭 필요한 별도 메서드 제공하는 편이 가장 이상적이지만 실무에서 데이터 
조회할 일이 매우 많으므로, Getter의 경우만 열어두는 것이 편리하다.
- 하지만 Setter를 호출하면 데이터가 변해, 막 열어두면 엔티티가 도대체 왜 어디서 변경되는지 추적하기 어려워짐.
- 그래서 엔티티를 변경할 떄는 Setter 대신에 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 한다.

### 값 타입은 변경 불가능하게 설계해야 한다.
- @Setter를 제거하고, 생성자로만 값을 초기화해서 변경 불가능한 클래스를 만들자.
- JPA 스펙상 엔티티나 임베디드 타입(@Embeddable)은 자바 기본 생성자를 public or protected로 설정해야 한다.
따라서 public 보다는 protected로 설정하는 것이 그나마 더 안전하다.
- JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플렉션 같은 기술을 사용할 수 있도록 지원해야 하기
때문이다.

## 엔티티 설계시 주의점
### 엔티티에는 가급적 Setter를 사용하지 말자.
- Setter가 열러 있으면 변경 포인트가 너무 많아 유지보수가 어려워진다.

### 모든 연관관계는 지연로딩으로 설정!
- 즉시로딩(EAGER)는 예측이 어렵고, 어떤 SQL이 실행될지 추적이 어렵다. 특히 JPQL 실행시 N + 1 문제가 자주 발생.
- 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야 한다.
- 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용하낟.
- @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.

### 컬렉션은 필드에서 초기화하자.
- null 문제에서 안전하다.
- 하이버네이트는 엔티티를 영속화할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 만약 getOrders()
처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제 발생할 수 있다. 따라서 필드레벨에서 생성하는
것이 가장 안전하고, 코드도 간결하다.

### 테이블, 컬럼명 생성 전략.
- 하이버네이트 기존 구현 : 엔티티의 필드명을 그대로 테이블의 컬럼명으로 사용
- 스프링 부트 신규 설정 (엔티티(필드) -> 테이블(컬럼))
    1. 카멜 케이스 -> 언더스코어 (memberPoint -> member_point)
    2. .(점) -> _(언더스코어)
    3. 대문자 -> 소문자

