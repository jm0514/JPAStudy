# 02. 플러시
- 플러시(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 플러시를 실행하면 다음과 같은 일이 일어난다.
1. 변경 감지가 동작해 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교, 수정된 엔티티를 찾아 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송. (등록, 수정, 삭제 쿼리)
- 영속성 컨텍스트를 플러시하는 방법은 3가지
1. em.flush() 직접 호출
2. 트랜잭션 커밋 시 플러시가 자동 호출됨
3. JPQL 쿼리 실행시 플러시가 자동 호출됨

### 직접 호출
- 엔티티 매니저의 flush()를 직접 호출해 영속성 컨텍스트를 강제로 플러시.
- 테스트나 다른 프레임워크와 JPA를 함꼐 사용할 때를 제외하고 거의 사용하지 않는다.

### 트랜잭션 커밋 시 플러시 자동 호출
- 데이터베이스에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 데이터베이스에 반영되지 않는다. 따라서 트랜잭션을 커밋하기 전에 꼭 플러시를 호출해 영속성 컨텍스트의 변경 내용을 데이터베이스에
반영해야 한다.
- JPA는 이런 문제를 예방하기 위해 트랜잭션 커밋시 플러시 자동 호출.

### JPQL 쿼리 실행 시 플러시 자동 호출
- JPQL이나 Criteria 같은 객체지향 쿼리를 호출할 때도 플러시가 실행된다. 
```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

// 중간에 JPQL 실행
query = em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```
- em.persist()로 memberA, B, C 모두 영속 상태. 이 엔티티들은 영속성 컨텍스트에는 있지만 DB에 반영되지 않은 상태. 이때 JPQL을 실행하면 어떻게 될까? JPQL은 SQL로 변환되어 DB에서 엔티티를 조회.
- 그런데 memberA, B, C는 아직 DBdㅔ 없어 쿼리 결과로 조회되지 않는다. 따라서 쿼리 실행 직전에 영속성 컨텍스트를 플러시해서 변경 내용을 DB에 반영해야 한다. 
- JPA는 이런 문제를 예방하기 위해 JPQL 실행할 때도 플러시를 자동 호출한다.
- 참고로 식별자를 기준으로 조회하는 find() 호출시에는 플러시가 실행되지 않는다.

## 플러시 모드 옵션
- 엔티티 매니저에 플러시 모드를 직접 지정하려면 javax.persistence.FlushModeType을 사용하면 된다.
  - FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시 (기본값)
  - FlushModeType.COMMIT : 커밋할 때만 플러시
- 플러시 모드를 별도로 설정하지 않으면 AUTO로 동작. 따라서 트랜잭션 커밋이나 쿼리 실행시에 플러시를 자동으로 호출. 대부분 AUTO 기본 설정 그대로 사용. COMMIT 모드는 성능 최적화로 사용 가능.
```java
em.setFlushMode(FlushModeType.COMMIT); // 플러시 모드 직접 설정
```
- 플러시라는 이름 때문에 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안 된다. 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이 플러시.
- 그리고 데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문. 트랜잭션 커밋 직전에만 변경 내용을 DB에 보내 동기화하면 된다.

