# 10.2.7 페치 조인
- 페치 (fetch) 조인은 SQL에는 없고 JPQL에서 성능 최적화를 위해 제공하는 기능.
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능. join fetch 명령어로 사용
- JPA 표준 명세에 정의된 페치 조인 문법은 다음과 같다.
```text
페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로
```

## 엔티티 페치 조인
- 페치 조인을 사용해 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회하는 JPQL은 다음과 같다.
```jpaql
select m
from Member m join fetch m.team
```
- 이렇게 하면 연관된 엔티티나 컬렉션을 함께 조회하는데 여기서는 회원(m)과 팀(m.team)을 함께 조회한다. 참고로 일반적인 JPQL 조인과는 다르게 m.team 다음에 별칭이 없는데 페치 조인은 별칭을 사용할 수 없다.
> 하이버네이트는 페치 조인에도 별칭 허용
- 실행된 SQL은 다음과 같다.
```sql
SELECT 
    M.*, T.*
FROM MEMBER M 
INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```
- 엔티티 페치 조인 JPQL에서 select m 으로 회원 엔티티만 선택했는데 실행된 SQL을 보면 `SELECT M.*, T.*` 로 회원과 연관된 팀도 함께 조회된 것을 확인할 수 있다.
- 그리고 회원과 팀 객체가 객체 그래프를 유지하면서 조회된다. 위 JPQL을 사용하는 코드를 보자.
```java
String query = "select m from Member m join fetch m.team";
List<Member> result = em.createQuery(query, Member.class)
    .getResultList();
for (Member member : result) {
    System.out.println("member = " + member.getUsername() + ", " + member.getTeam().getName());
}
```
- 출력결과
```text
member = 회원1, 팀A
member = 회원2, 팀A
member = 회원3, 팀B
```
- 회원과 팀을 지연 로딩으로 설정했다고 가정하자. 회원을 조회할 때 페치 조인을 사용해서 팀도 함꼐 조회했으므로 연관된 팀 엔티티는 프록시가 아닌 실제 엔티티다.
- 따라서 연관된 팀을 사용해도 지연 로딩이 일어나지 않는다. 그리고 프록시가 아닌 실제 엔티티이므로 회원 엔티티가 영속성 컨텍스트에서 분리되어 준영속 상태가 되어도 연관된 팀을 조회할 수 있다.

## 컬렉션 페치 조인
- 일대다 관계인 컬렉션을 페치 조인 해보자.
```jpaql
select t
from Team t join fetch t.members
```
- 팀(t)을 조회하면서 페치 조인을 사용해서 연관된 회원 컬렉션 (t.members)도 함꼐 조회한다.
```sql
SELECT 
    T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID = M.TEAM_ID
```
- 컬렉션을 페치 조인한 JPQL에서 select t로 팀만 선택했는데 실행된 SQL을 보면 `T.*, M.*` 로 팀과 연관된 회원도 함께 조회한 것을 확인할 수 있다.
- 그리고 TEAM 테이블에서 '팀A'는 하나지만 MEMBER 테이블과 조인하면서 결과가 증가해서 '팀A'가 2건 조회된다. 
> 일대다 조인은 결과가 증가할 수 있지만 일대일, 다대일 조인은 결과가 증가하지 않는다.
- 컬렉션 페치 조인 사용
```java
String query = "select t from Team t join fetch t.members";
List<Team> result = em.createQuery(query, Team.class)
    .getResultList();

for (Team team : result) {
    System.out.println("team = " + team.getName() + " | members = " + team.getMembers().size());
    for (Member member : team.getMembers()) {
        System.out.println("-----> member = " + member);
    }
}
```
```java
team = 팀A | members = 2
-----> member = Member{id=3, username='회원1', age=0}
-----> member = Member{id=4, username='회원2', age=0}
team = 팀A | members = 2
-----> member = Member{id=3, username='회원1', age=0}
-----> member = Member{id=4, username='회원2', age=0}
team = 팀B | members = 1
-----> member = Member{id=5, username='회원3', age=0}
```
- 출력 결과를 보면 같은 '팀A'가 2건 조회된 것을 확인할 수 있다.

## 페치 조인과 DISTINCT
- SQL의 DISTINCT 는 중복된 결과를 제거하는 명령어. JPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하는 것은 물론, 애플리케이션에서 한 번 더 중복을 제거한다.
```java
String query = "select DISTINCT t from Team t join fetch t.members";
List<Team> result = em.createQuery(query, Team.class)
    .getResultList();

for (Team team : result) {
    System.out.println("team = " + team.getName() + " | members = " + team.getMembers().size());
    for (Member member : team.getMembers()) {
        System.out.println("-----> member = " + member);
    }
}
```
```java
team = 팀A | members = 2
-----> member = Member{id=3, username='회원1', age=0}
-----> member = Member{id=4, username='회원2', age=0}
team = 팀B | members = 1
-----> member = Member{id=5, username='회원3', age=0}
```
- 위 결과에선 애플리케이션에서 distinct 명령어를 보고 중복된 데이터를 걸러낸다. select distinct t 의 의미는 팀 엔티티의 중복을 제거하라는 것. 따라서 중복인 팀A는 하나만 조회된다.

## 페치 조인과 일반 조인의 차이
- 페치 조인을 사용하지 않고 조인만 사용하면 어떻게 될까?
- 내부 조인 JPQL
```jpaql
select t
from Team t join t.members m
```
```sql
SELECT
    T.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
```
- JPQL에서 팀과 회원 컬렉션을 조인했으므로 회원 컬렉션도 함께 조회할 것으로 기대해선 안 된다. 실행된 SQL의 SELECT절을 보면 팀만 조회하고 조인했던 회원은 전혀 조회하지 않는다.
- JPQL은 결과를 반환할 떄 연관관계까지 고려하지 않는다. 단지 SELECT절에 지정한 엔티티만 조회할 뿐이다. 따라서 팀 엔티티만 조회하고 연관된 회원 컬렉션은 조회하지 않는다. 만약 회원 컬렉션을 지연 로딩으로
설정하면 프록시나 아직 초기화하지 않은 컬렉션 레퍼를 반환한다. 즉시 로딩으로 설정하면 회원 컬렉션을 즉시 로딩하기 위해 쿼리를 한 번 더 실행한다.
- 반면에 페치 조인을 사용하면 연관된 엔티티도 함께 조회한다.
- 컬렉션 페치 조인 JPQL
```jpaql
select t
from Team t join fetch t.members
where t.name = '팀A'
```
- SELECT T.*, M.* 로 팀과 회원을 함꼐 조회한 것을 알 수 있다.
- 실행된 SQL은 다음과 같다.
```sql
SELECT 
    T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID = M.TEAM_ID
WHERE T.NAME = '팀A'
```
