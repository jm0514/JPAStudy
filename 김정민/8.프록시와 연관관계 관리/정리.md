
###단방향 양방향
* 한쪽만 참조하면 단방향 양쪽 서로 참조하면 양방향

* 양방향에서는 한 테이블에서 외래키를 관리해야 함

* 외래키가 있는 곳이 주인

* 주인이 아닌 곳은 mappedBy속성을 지정함

* 연관관계의 주인과 비즈니스적 중요도와는 별개.

* 초기에 단방향으로 설정하고 필요할 때 양방향으로 수정

###다대일 (N:1)

* 외래키 하나로 두 테이블이 연관관계를 맺음

* 테이블 설계에 따라서 외래키는 다(N)쪽에 있어야 함

* 다(N)쪽이 연관관계의 주인

* 주인의 반대편은 조회만 가능

###일대다(1:N)

* 일(1)이 연관관계의 주인

* 객체와 테이블 설계의 차이가 있음

* 단점때문에 다대일 양방향 매핑을 권장함

###일대일(1:1)

* 주 테이블에 외래 키가 있는 방식을 하거나 대상 테이블에 외래 키가 있는 방식 2가지로 나뉨

* 객체 지향 개발자는 전자를 선택 데이터베이스 개발자는 후자를 선택

###다대다(N:N)

* 실무에서는 사용을 권장하지 않고 OneToMany와 ManyToOne으로 나눠서 설계

##상속관계 매핑
####주요 어노테이션
***
@Inheritance(strategy=InheritanceType.XXX`

JOINED: 조인 전략

SINGLE_TABLE: 단일 테이블 전략

`@DiscriminatorColumn(name=“DTYPE”)`

`@DiscriminatorValue(“XXX”)`
***

조인전략은 단점의 영향이 미미하기 때문에 기본으로 사용함

테이블이 단순할 경우 단일 테이블 전략을 사용

###MappedSuperclass

테이블과는 관계가 없고 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할

###프록시

* `em.find()`: 데이터베이스를 통해서 실제 엔티티 객체 조회

* `em.getReference()`:데이터베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회

* 실제 클래스를 상속받아 만들어졌지만 겉모양만 같음

* 프록시 객체를 호출하면 실제 객체의 메서드를 호출함



### 지연로딩

* LAZY를 사용해서 프록시 객체를 사용

* 실제 객체를 사용하는 시점에 DB를 조회

###즉시로딩

* EAGER를 사용해서 연관된 객체를 전부 조회

* 가급적 지연로딩만 사용하는 것을 권장

* JPQL fetch조인이나 엔티티 그래프 기능을 사용하자

###CASCADE

* 특정 엔티티를 영속상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들고 싶을때 사용함

###고아객체

* 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아객체로 보고 삭제하는 기능