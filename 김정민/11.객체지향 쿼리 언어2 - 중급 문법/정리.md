#정리
## 값타입
### JPA의 데이터 타입 분류
* 엔티티 타입
    * @Entity로 정의하는 객체
    * 데이터가 변해도 식별자로 지속해서 추적 가능
* 값 타입
    * int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
    * 식별자가 없고 값만 있으므로 변경시 추적 불가

###기본 값 타입
* 생명주기를 엔티티의 의존
* 값 타입은 공유하면 안됨

### 임베디드 타입
* 새로운 값 타입을 직접 정의할 수 있음
* JPA는 임베디드 타입이라고 함
###임베디드 타입의 장점
* 재사용
* 높은 응집도
* 임베디드 타입은 엔티티의 값일 뿐
* 임베디드 타입을 사용하기 전과 후에 매핑하는 **테이블은 같음**
### 객체 타입의 한계
* 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.
* 값 타입은 불변 객체로 설계해야함
* 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨

### 값 타입의 비교
* 값 타입은 a.equals(b)를 사용해서 동등성을 비교해야 함
### 값 타입 컬렉션의 제약사항
* 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장
* 실무에서는 자주 사용하지 않고 간단한 내용으로만 값 타입 컬렉션 사용(추적할 필요가 없고 값이 바뀌어도 update할 필요가 없을 때)

# JPQL 기본문법
* JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아닌 엔티티 객체를 대상으로 쿼리함
* JPQL문법은 기본 SQL문법과 동일
* select m from Member as m where m.age > 18 (대소문자를 구분함)
* 엔티티와 속성은 대소문자 구분
* JPQL 키워드는 대소문자 구분을 하지 않음(SELECT, FROM, where)
* 엔티티 이름 사용, 테이블 이름이 아님(Member)
* 별칭은 필수(as는 생략 가능)
### 프로젝션
* SELECT m FROM Member m 
* SELECT m.username, m.age FROM Member m
###페이징
* setFirstResult(int startPosition): 조회 시작 위치(0부터 시작)
* setMaxResults(int maxResult): 조회할 데이터 수
###조인
* 내부 조인: SELECT m FROM Member m [INNER] JOIN m.team t
* 외부 조인: SELECT m FROM Member m LEFT[OUTER] JOIN m.team t
* 세타 조인: select count(m) from Member m, Team t where m.username = t.name
###서브쿼리
* 팀A 소속인 회원  
  select m from Member m  
  where exists (select t from m.team t where t.name = ‘팀A')
# JPQL 중급문법
### 경로 표현식
* .(점)을 찍어 객체 그래프를 탐색하는 것
* * 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM(JOIN)절에 영향을 줌
* **가급적 명시적 조인을 사용**
### 페치 조인
* SQL 조인 종류가 아님
* JPQL에서 **성능 최적화**를 위해 제공하는 기능
* 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
* 일반 조인은 실행시 연관된 엔티티를 함께 조회하지 않음
* 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
* 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 다른 결과를 내야 하는 경우, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터 들만 조회해서 DTO로 반환하는 것이 효과적

# 생각해보자
* 객체 타입을 불변 객체처럼 사용하려면?? (객체 타입의 한계)
  * _~~생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨~~_
* 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 다른 결과를 내야하는 경우는??
  * ~~일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 변환하는 것이 효과적~~
* JPQL에서 성능 최적화를 위해 제공하는 기능은??
  * ~~페치 조인~~


