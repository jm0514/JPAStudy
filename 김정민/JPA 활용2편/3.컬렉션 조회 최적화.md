# 컬렉션 조회 최적화
* 앞선 예제들은 XtoOne관계를 다뤘지만, 이번엔 컬렉션인 일대다(OneToMany)를 조회하고 최적화하는 방법을 알아보자
### 주문 조회 V1 : 엔티티 직접 노출
```java
/**
 * V1. 엔티티 직접 노출
 * - 엔티티가 변하면 API 스펙이 변한다.
 * - 트랜잭션 안에서 지연 로딩 필요
 * - 양방향 연관관계 문제
 *
 * V2. 엔티티를 조회해서 DTO로 변환(fetch join 사용X)
 * - 트랜잭션 안에서 지연 로딩 필요
 * V3. 엔티티를 조회해서 DTO로 변환(fetch join 사용O)
 * - 페이징 시에는 N 부분을 포기해야함(대신에 batch fetch size? 옵션 주면 N -> 1 쿼리로 변경
가능)
 *
 * V4. JPA에서 DTO로 바로 조회, 컬렉션 N 조회 (1 + N Query)
 * - 페이징 가능
 * V5. JPA에서 DTO로 바로 조회, 컬렉션 1 조회 최적화 버전 (1 + 1 Query)
 * - 페이징 가능
 * V6. JPA에서 DTO로 바로 조회, 플랫 데이터(1Query) (1 Query)
 * - 페이징 불가능...
 *
 */
@RestController
@RequiredArgsConstructor
public class OrderApiController {
     private final OrderRepository orderRepository;
     /**
     * V1. 엔티티 직접 노출
     * - Hibernate5Module 모듈 등록, LAZY=null 처리
     * - 양방향 관계 문제 발생 -> @JsonIgnore
     */
     @GetMapping("/api/v1/orders")
     public List<Order> ordersV1() {
         List<Order> all = orderRepository.findAll();
         for (Order order : all) {
         order.getMember().getName(); //Lazy 강제 초기화
         order.getDelivery().getAddress(); //Lazy 강제 초기환
         List<OrderItem> orderItems = order.getOrderItems();
         orderItems.stream().forEach(o -> o.getItem().getName()); //Lazy 강제초기화
         }
     return all;
     }
}
```
* 데이터 노출, 유연성 떨어짐, 무한 루프등의 문제로 엔티티를 직접 노출하는 방법은 좋지 않다.
### 주문 조회 V2: 엔티티를 DTO로 변환
```java
@GetMapping("/api/v2/orders")
public List<OrderDto> ordersV2() {
    List<Order> orders = orderRepository.findAll();
    List<OrderDto> result = orders.stream()
        .map(o -> new OrderDto(o))
        .collect(toList());
    
     return result;

}

@Data
static class OrderDto {
    private Long orderId;
    private String name;
    private LocalDateTime orderDate; //주문시간
    private OrderStatus orderStatus;
    private Address address; //value object는 바뀔일이 없다.
    //private List<OrderItem> orderItems; 
    // Dto안에 Entity가 있으면 안된다(외부로 Entity가 노출됨, 엔티티 수정시 Api도 전부 바꿔야 함). 
    // 모두 Dto로 바꿔주어야 한다. 그래서 OrderItemDto클래스를 따로 생성해준다.
    private List<OrderItemDto> orderItems;
    public OrderDto(Order order) {
        orderId = order.getId();
        name = order.getMember().getName();
        orderDate = order.getOrderDate();
        orderStatus = order.getStatus();
        address = order.getDelivery().getAddress();
        orderItems = order.getOrderItems().stream()
                .map(orderItem -> new OrderItemDto(orderItem))
                .collect(toList());
    }
}

@Data
static class OrderItemDto {
    // 클라이언트 입장에서 item의 모든 정보가 필요하지 않다. 
    // 예를 들어 필요한 Api가 상품명, 가격, 수량 만 필요할 경우 이렇게 설계
    // 외부로는 OrderItemDto로 래핑이 돼서 나간다.
    private String itemName;//상품 명
    private int orderPrice; //주문 가격
    private int count; //주문 수량
    public OrderItemDto(OrderItem orderItem) {
        itemName = orderItem.getItem().getName();
        orderPrice = orderItem.getOrderPrice();
        count = orderItem.getCount();
    }
}
```
* **Dto안에 Entity를 Dto로 수정(주석으로 설명)**
* 지연 로딩으로 많은 SQL 실행
* SQL 실행 수
  * `order` 1번
  * `member`, `address` N번(order 조회 수 만큼)
  * `orderItem` N번(order 조회 수 만큼)
  * `item` N번(orderItem 조회수 만큼)
* 지연 로딩은 영속성 컨텍스트에 있으면 영속성 컨텍스트에 있는 엔티티를 사용하고 없으면 SQL을 실행한다.
* 따라서 같은 영속성 컨텍스트에서 이미 로딩한 회원 엔티티를 추가로 조회하면 SQL을 실행하지 않는다.

### 주문 조회 V3: 페치 조인
```java
//OrderApiController 부분은 orderRepository.findAllWithItem();을 제외하고 같음

//OrderRepository
public List<Order> findAllWithItem() {
        return em.createQuery(
        "select distinct o from Order o" +
            " join fetch o.member m" +
            " join fetch o.delivery d" +
            " join fetch o.orderItems oi" +
            " join fetch oi.item i", Order.class)
        .getResultList();
        }
```
* 페치 조인으로 인해 SQL이 1번만 실행됨
* 여기서 2개의 주문 내역을 호출했는데 결과는 4개로 뻥튀기가 됐다.(심지어 중복된 id끼리 참조값까지 같음)
* JPA입장에서는 이것을 중복 처리하는 것은 섣부른 판단이다.(데이터의 관점에서 봤을 때는 4개로 주는 것이 맞음) <- 이것이 DB와 JPA의 페러다임 차이인가??
* 이것을 방지하기 위해 distinct를 사용
* 하지만 DB의 distinct는 한 줄의 내용이 전부 같아야 적용되는데 H2데이터 베이스를 보면 내용이 다른 부분이 있다.
* 그것은 객체 Order에서 id값이 같은 경우 중복을 제거해서 가져다준다.(JPA에서 distinct를 쓰면 SQL에도 작성해주지만, JPA와 DB의 distinct는 다름)
* **단점**
  * 페치 조인을 할 경우 페이징이 불가능하다.
  * 컬렉션 페치 조인은 1개만 사용가능하다.
### 주문 조회 V3.1: 페이징과 한계 돌파
* 일대다에서 일(1)을 기준으로 페이징을 하는 것이 목적인데, 데이터는 다(N)를 기준으로 row가 생성된다.
* 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB데이터를 읽어서 메모리에서 페이징을 시도한다. 최악의 경우 장애로 이어질 수 있다.
* 먼저 XToOne관계를 모두 페치조인 한다. XToOne관계는 row수를 증가시키지 않아 페이징 쿼리에 영향을 주지 않는다.
* 컬렉션은 지연 로딩으로 조회한다.
* 지연 로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size`, `@BatchSize`를 적용한다.
  * `hibernate.default_batch_fetch_size`: 글로벌 설정
  * `@BatchSize`: 개별 최적화
  * 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size만큼 IN 쿼리로 조회한다.
```java
// OrderRepository
public List<Order> findAllWithMemberDelivery(int offset, int limit) {
     return em.createQuery(
         "select o from Order o" +
         " join fetch o.member m" +
         " join fetch o.delivery d", Order.class)
     .setFirstResult(offset)
     .setMaxResults(limit)
     .getResultList();
}

// OrderApiController
/**
 * V3.1 엔티티를 조회해서 DTO로 변환 페이징 고려
 * - ToOne 관계만 우선 모두 페치 조인으로 최적화
 * - 컬렉션 관계는 hibernate.default_batch_fetch_size, @BatchSize로 최적화
 */
@GetMapping("/api/v3.1/orders")
public List<OrderDto> ordersV3_page(@RequestParam(value = "offset", defaultValue = "0") int offset,
                                    @RequestParam(value = "limit", defaultValue = "100") int limit) {
            List<Order> orders = orderRepository.findAllWithMemberDelivery(offset,
            limit);
            
            List<OrderDto> result = orders.stream()
                .map(o -> new OrderDto(o))
                .collect(toList());
            return result;
}

// 옵션 설정
    spring:
        jpa:
          properties:
            hibernate:
              default_batch_fetch_size: 1000
```
* 개별로 설정하는 것은 `@BatchSize`를 적용
* 원래 OrderItems을 UserA(Id:4), UserB(Id:11)로 각각 가져왔지만, 옵션을 적용하고 IN 쿼리를 통해 한 번에 가져오는 것을 확인 할 수 있다.
* 컬렉션을 IN 쿼리로 한번에 가져옴
* **장점**
  * 쿼리 호출 수가 1+N -> 1+1로 최적화 된다.
  * 조인보다 DB데이터 전송량이 최적화 된다.
  * (Order와 OrderItem을 조인하면 Order가 OrderItem 만큼 중복돼서 조회한다. 이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없다.)
  * 페치 조인 방식과 비교해서 쿼리 호출 수는 약간 증가하지만, DB 데이터 전송량이 감소한다.
  * 컬렉션 페치 조인은 페이징이 불가능 이 방법은 페이징 가능!
* **결론**
  * XToOne 관계는 페치 조인으로 쿼리 수를 줄이고, 나머지는 `hibernate.default_batch_fetch_size`로 최적화 하자.
  * XToMany 관계는 페치 조인을 사용하지 말자.
* `default_batch_fetch_size`의 크기는 100~1000사이 권장
